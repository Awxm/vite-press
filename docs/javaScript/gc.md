# 垃圾回收机制

## 什么是垃圾回收机制

垃圾回收机制(Garbage Collection)简称GC，是指javaScript中使用**内存管理系统**的基本组成部分。(主要是回收内存的)

javaScript在创建变量（对象、字符串等）的时候自动分配内存，它会**自动**识别**不再使用**的变量并**自动释放**。这个释放的过程就是垃圾回收.

垃圾回收器会自动回收（只要对象字符串等等不在使用）

## 内存的生命周期

内存的生命周期分为三个阶段：

1. 分配阶段：系统会为变量、函数、对象分配内存。
2. 使用阶段：变量被使用（读写对象、函数调用），并在内存中留下痕迹。
3. 回收阶段：变量、函数调用执行完毕 垃圾回收器会自动回收不再使用的变量，释放内存。

判断一个函数变量有没有回收 只需要看一点就是这个函数**有没有在使用**，针对一些全局变量，我们可以关闭浏览器或者刷新页面或者手动调用gc()函数进行垃圾回收。针对局部变量，在函数执行完毕后，局部变量会被回收。当然闭包除外。

## 垃圾回收机制的算法

垃圾回收机制的算法有两种：

1. 引用计数算法：为每个对象维护一个引用计数器，当一个对象被引用时，引用计数器加1；多次引用多次累加；当引用失效时，引用计数器减1。当引用计数器为0时，可以回收。

```javascript
let user = {
    name:'chenxin'
    age:26
}
let u = user
user = 1
u = null

```

我们解释一下上面这段内存：

user这个对象被分配了内存，我们的**栈**存放的是user的**引用地址**，**堆**存放的是user对象本身{name:'chenxin',age:26}。

当user赋值给u时，u的栈内存存放的是user的地址，但是user堆内存的引用计数器增加为2，因为u已经引用了它。

当user赋值为1的时候，user的引用计数器减1，但是user对象本身{name:'chenxin',age:26}并没有被回收，因为u还在引用它。

当u赋值为null的时候，u的引用计数器减1，这时候user对象的引用计数器为0,可以被回收。

引用计数法会存在一个弊端就是**循环引用**

```javascript

function test(){
const o1= {}
const o2= {}
o1.a = o2
o2.a = o1
}

// 因为他们的引用次数永远不会是零。这样的话当数据量大的时候就会导致内存泄漏
```

2. 标记清除算法

引用计数法基本上不使用了，因为它太复杂，而且效率也不高。标记清除算法是最常用的垃圾回收算法。标记清除算法的基本思想是：不在使用的对象，就标记为“无法达到的对象”，然后进行内存清除。

1. 标记阶段：从根对象开始，递归遍历所有能到达的对象，标记所有能达到的对象。
2. 回收阶段：清除掉所有标记为“无法达到的对象”。

针对上面的例子

```javascript

function test(){
    
const o1= {}
const o2= {}
o1.a = o2
o2.a = o1
}

```

 1. 标记阶段

 根对象是test函数的作用域，所以从test函数开始标记

 标记o1和o2，因为他们的a属性指向了对方

 2. 回收阶段

 清除掉所有标记为“无法达到的对象”

 因为o1和o2都没有被标记，所以它们都可以被回收

 但是o1和o2的a属性指向的对象都被标记了，所以它们也不能被回收

 所以这两个对象会留在内存中，但是它们的a属性指向的对象已经被回收了。
