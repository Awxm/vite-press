# Diff

简单来说就是比较两颗树,因为render会生成两棵树，新的一棵树和就旧的一颗树，然后对两颗树进行比较,找出两棵树的不同之处,然后更新就是diff（difference）

当组件创建和更新时，vue均会执行内部的update函数，该函数在内部调用render函数生成虚拟dom树，组件会指向新树，然后vue将新旧两树进行对比，找到差异点，最终更新到真实dom

对比差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程

在对比时，vue采用深度优先、逐层比较的方式进行比对。

在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的

具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组;如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。

在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节-一样的对比流程，如果发现不同，则移动真实dom到合适的位置。

这样一直递归的遍历下去，直到整棵树完成对比。

## Diff的时机

简单理解:数据更新的时候就会发生Diff,因为数据更新会导致重新渲染,重新渲染就是运行render函数得到新的虚拟dom树

当组件创建时，以及依赖的属性或数据变化时，会运行一个函数，该函数会做两件事:

1. 生成虚拟dom树运行_render生成一棵新的虚拟dom树(vnode tree)
2. 运行_update，传入虚拟dom树的根节点，对新旧两棵树进行对比，最终完成对真实dom的更新.

```javascript
// vue 构造函数
function Vue(options) {
  //
  this._update = function(vnode) {
    // 1. 生成虚拟dom树
    var oldVnode = this._vnode;
    this._vnode = vnode;
    // 2. 对比两棵树
    var patches = diff(oldVnode, vnode);
    // 3. 更新真实dom
    patch(this._el, patches);
  }
  var updatecomponent =  () => {
    this._update(this._render());
  }
  new Watcher(updateCoaponent);
}
```

diff就发生在_update 函数的运行过程中

## _update

 _update 函数会传入一个vnode作为参数,这就是新生成的虚拟dom树

同时_update函数通过当前组件的_vnode属性，拿到旧的虚拟dom树

_update函数首先会给组件的_vnode属性重新赋值，让它指向新树

然后会判断旧树是否存在:

* 不存在:说明这是第一次加载组件，于是通过内部的patch函数，直接历新树，为每个节点生成真实DOM，挂载到每个节点的elm属性上
* 存在:说明之前已经渲染过该组件，于是通过内部的patch的数，对新旧两棵树进行对比，完成对所有真实dom的最小化处理，同时让新树的节点对应合适的真实dom。

## patch

1. 「相同」:是指两个节点的标签类型、key（不只有在for循环里面才会有,所有组件都可以写key）值均相同，但input 元素还要看type 属性.

2. 「新建元素」:是指根据一个虚拟节点提供的信息，创建一个真实dom元素，同时挂载到虚拟节点的elm属性上

3. 「销毁元素」:是指:vnode.elm.remove()

4. 「更新」:是指对两个虚拟节点进行对比更新，它仅发生在两个虚拟节点「相同」的情况下。具体过程稍后描述。

5. 「对比子节点」:是指对两个虚拟节点的子节点进行对比(深度便利)，具体过程稍后描述

## elm

elm属性是真实dom的引用，在创建虚拟dom树时，会为每个节点生成一个真实dom，并将其挂载到每个节点的elm属性上。

### 具体过程

#### 「相同」

```javascript
// 写一个the same Vnode

// <h1>hello</h1> <h1>hello</h1>
// 虚拟节点
//  {
//   tag: 'h1',
//   text: 'hello',
//   key:undefined.
// }
//  {
//   tag: 'h1',
//   text: 'hello',
//   key:undefined.
// }
// input 元素还要看type
// aa  bb 虚拟节点是不是也是一样的
// {tag:undefined,text:'aa',key:undefined}
// {tag:undefined,text:'bb',key:undefined}
```

#### 详细流程

1. 根节点对比
拿到两颗树 新树和旧的树对根节点进行对比，判断两个根节点是不是同一个节点。

* 「相同」，进入「更新」流程

1. 将旧节点的真实dom赋值到新节点:newVnode.elm =oldVnode.elm
2. 对比新节点和旧节点的属性，有变化的更新到真实dom中
3. 当前两个节点处理完毕，开始「对比子节点」

* 不「相同」
1.新节点递归「新建元素」
2.旧节点「销毁元素」

2. 「对比子节点」
在「对比子节点」时，vue一切的出发点，都是为了:

* 尽量啥也别做
* 不行的话，尽量仅改动元素属性
* 还不行的话，尽量移动元素，而不是删除和创建元素
* 还不行的话，删除和创建元素

## 没有key的影响

加上key 就可以知道什么节点对应什么节点  但是如果没有key  那么就只能通过顺序来判断顺序不同就算是同一个节点也会被认为是不同的节点，原则上来讲能不修改就不修改，这样就会把所有的节点进行更新
